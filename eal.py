"""
    EAL - Easy Addon Localisation

    EAL aims to make localising and translation of Garry's Mod addons much easier by
    automatically finding string values that require translations and creating
    templates for translators to fill in.

    EAL also changes your addon code to implement these language changes automatically
    by replacing hard-coded strings with global variables. It will also create an autorun
    file named eal.lua which simply facilitates the changing of languages. You may of course
    implement this into your own config lua file.

    @author DevonDF
    @website devon.computer
"""
import os
import pathlib
import logging
import re
import warnings
import sys
warnings.simplefilter("ignore")
logging.basicConfig(format="%(levelname)s: %(message)s", level=logging.INFO)

VERSION = "v0.0.1"
LANGUAGES = ["bg", "cs", "da", "de", "el", "en", "es", "et", "fi", "fr", "he", "hr", "hu", 
            "it", "ja", "ko", "lt", "nl", "no", "pl", "pt-BR", "pt-PT", "ru", "sk", "sv-SE", "th",
            "tr", "uk", "vi", "zh-CN", "zh-TW"] # List of supported Garry's Mod languages
PATH = pathlib.Path(__file__)
ADDON_PATH = None
ADDON_NAME = ""

class TranslatableString():
    """
        Represents a translatable string
    """

    def __init__(self, raw_string):
        """
            Create a TranslatableString from a raw string
                Structure of a translatable string should be %{comment}string
        """
        meta = re.search(r'%({[^"]*})?', raw_string).group(0)
        self.string = raw_string.replace(meta, "")
        comment = re.search(r'(?<={)[^"\']*(?=})', meta)
        self.comment = comment.group(0) if comment else None
        self.translation = self.string

class TranslatableStringManager():
    """
        The manager handles collecting translatable strings such that
            repeats are removed, as well as providing utility functions for use
    """

    def __init__(self):
        self.translatable_strings = []
        self._strings = {}
    
    def add_string(self, trans_string):
        """
            Add a translatable string

            @params - TranslatableString trans_string - String to add

            @returns - Boolean - Whether added or not
        """
        if (trans_string.string in self._strings.keys()):
            index = self._strings[trans_string.string]
            original = self.translatable_strings[index]
            # If this one has a comment attached, but the currently stored doesn't, copy the comment over
            if (original.comment == None and trans_string.comment != None):
                original.comment = trans_string.comment
            return False
        
        self.translatable_strings.append(trans_string)
        self._strings[trans_string.string] = len(self.translatable_strings) - 1
        return True
    
    def has_string(self, string):
        """
            Returns whether a given string has already been registered
        """
        return string in self._strings.keys()
    
    def remove_string(self, string):
        """
            Remove a translatable string
        """
        if (self.has_string(string)):
            index = self._strings[string]
            self.translatable_strings.pop(index)
            del self._strings[string]


    def get_translation_file_code(self):
        """
            Get the code for the translations of all held strings
        """

        code = ""

        for trans_string in self.translatable_strings:
            code += f"\t[\"{trans_string.string}\"] = \"{trans_string.translation}\","
            if (trans_string.comment != None):
                code += f" // {trans_string.comment}"
            code += "\n"
        
        return code
        
    def __len__(self):
        return len(self.translatable_strings)


def generate_lua_comment(extra=""):
    """
        Generate a standard LUA comment with a given extra string

        @params - extra - String to add to the comment

        @returns - String - Lua comment
    """

    return f"/**\n\tThis file was automatically generated by EAL\n\n\t{extra}\n\n\t@author Devon\n\t@website devon.computer\n\t@Github:https://github.com/DevonDF/EAL-Easy-Addon-Localisation\n**/\n\n"

def get_translatable_strings():
    """
        Returns all the translatable strings within the current addon

        By default, this is all strings in .lua files that begin with %

        @returns - TranslatableStringManager - New Manager that holds all found translatable strings
    """

    def _scan_file(path):
        """
            Scan the file at the given path for translatable strings
            and append it to translatable_strings
        """
        data = ""
        with open(path, "r") as f:
            for line in f.readlines():
                strings = re.findall(r'"%[^"]+"', line) + re.findall(r'[[%[^"]+]]', line) + re.findall(r'\'%[^"]+\'', line)
                for string in strings:
                    raw_string = string[2:-2] if string.startswith("[[") else string[1:-1]
                    trans_string = TranslatableString(raw_string)
                    line = line.replace(string, f"EAL.translations[\"{ADDON_NAME}\"][EAL.language][\"{trans_string.string}\"]")
                    translatable_string_manager.add_string(trans_string)
                data += line

        with open(path, "w") as f:
            f.write(data)

    # We are using a dict so we have added benefit of auto-merging any same strings together
    translatable_string_manager = TranslatableStringManager()
    
    for lua_file in ADDON_PATH.glob('**/*.lua'):
        _scan_file(lua_file)
    
    return translatable_string_manager

def write_translation_file(lang_dir, lang, translatable_strings):
    """
        Write the translation file for the given language and strings in the given directory

        Performs checks in order to facilitate re-running EAL multiple times, so we are overwriting
            previous translations
        
        @params - pathlib.Path - Directory to place files
        @params - String - Language to write
        @params - TranslatableStringManager translatable_strings - Manager for strings to add
    """

    file_name = lang_dir.joinpath(f"{lang}.lua")
    found_declarations = []
    if (file_name.exists()):
        with open(file_name, "r") as f:
            for line in f.readlines():
                if (re.search(r'\s*\["[^"]*"\]\s*=\s*"[^"]*"', line)):
                    # This line contains a translation
                    declaration = line.split("=")
                    if (len(declaration) != 2):
                        continue
                    normal_string = re.search(r'(?<=\[")[^"]*(?="\])', declaration[0]).group(0)
                    translatable_strings.remove_string(normal_string) # Remove as we already have this string
                    found_declarations.append(line)
                    

    with open(file_name, "w") as f:
            template = generate_lua_comment("Edit the right-hand side to provide translation to the left-hand side")
            template += f"EAL.translations[\"{ADDON_NAME}\"][\"{lang}\"] = {{\n"
            template += "".join(found_declarations)
            template += translatable_strings.get_translation_file_code()
            template += "}"
            f.write(template)

def inject_eal_load(path):
    """
        Inject the EAL load script into the file at the given path

        @params - pathlib.Path or String - Path to inject into

        @returns - Boolean - Whether successful
    """

    eal_path = ADDON_PATH.joinpath("lua", "eal_" + ADDON_NAME)

    with open(path, "r+") as f:
        if (f.readline().find(f"include(\"{eal_path.name}/eal.lua\")") != -1): 
            return True
        f.seek(0,0)
        data = f.read()
        f.seek(0,0)
        f.write(f"AddCSLuaFile(\"{eal_path.name}/eal.lua\")\ninclude(\"{eal_path.name}/eal.lua\")\r\n" + data)
    
    return True


def main():
    """
        Script execution starts here
    """
    global ADDON_PATH, ADDON_NAME

    logging.info("Loading EAL version " + VERSION)
    if (not PATH.parent.joinpath("lua").exists()):
        logging.critical("Error; Please run eal.py from the root directory of the addon to translate")
        return
    else:
        ADDON_PATH = PATH.parent
        ADDON_NAME = ADDON_PATH.name
        logging.info("Registered addon name as " + ADDON_NAME)
    
    logging.warning("It is recommended to backup your addon before running EAL! Running EAL on your addons could possibly lead to"
                + " loss of work or functionality. Use at your own risk.")
    
    if (input("Do you want to continue at your own risk? (y/n)\n").lower() not in ["y", "yes"]):
        return

    # Get all translatable strings in lua files
    translatable_string_manager = get_translatable_strings()

    if (len(translatable_string_manager) == 0):
        logging.critical("Found no translatable strings in addon.. exiting")
        return

    logging.info(f"Found {len(translatable_string_manager)} translatable strings")

    # Create our template directory
    lang_dir = ADDON_PATH.joinpath("lua", "eal_" + ADDON_NAME, "langs")
    lang_dir.mkdir(parents=True, exist_ok=True)

    # Create our templates
    for lang in LANGUAGES:
        write_translation_file(lang_dir, lang, translatable_string_manager)
    
    # Create our loader and config
    loader_config_dir = ADDON_PATH.joinpath("lua", "eal_" + ADDON_NAME)
    
    with open(loader_config_dir.joinpath(f"eal.lua"), "w") as f:
        template = generate_lua_comment()
        template += f"EAL = EAL or {{}}\nEAL.translations = EAL.translations or {{}}\n\nEAL.translations[\"{ADDON_NAME}\"] = {{}}\n"
        template += "EAL.defaultLanguage = \"en\" // The default language for client and server\n"
        template += f"// When changing, make sure to use the exact language code of a file found in: {lang_dir.name}\n"
        for lang in LANGUAGES:
            template += f"AddCSLuaFile(\"{lang_dir.name}/{lang}.lua\")\n"
            template += f"include(\"{lang_dir.name}/{lang}.lua\")\n"
        template += "EAL.language = EAL.defaultLanguage\n"

        f.write(template)
    
    # Now attempt to find an autorun file to hook into it
    autorun_dir = ADDON_PATH.joinpath("lua", "autorun")

    autorun_files = list(autorun_dir.glob("*.lua"))
    injected = False
    if (len(autorun_files) == 0):
        logging.warning("No lua files found in autorun... creating new one")
        new_file = autorun_dir.joinpath("eal_load.lua")
        new_file.touch(exist_ok=True)
        injected = inject_eal_load(new_file)
    elif (len(autorun_files) > 1):
        logging.warning("More than one lua file found in autorun... please select the MAIN loader, that is, " +
                        "the file that loads addon files with translatable strings")
        inject_file = None
        inject_file_id = None
        while (inject_file_id not in range(len(autorun_files))):
            print("\n".join([str(i) + ":" + str(x.name) for i,x in enumerate(autorun_files)]))
            try:
                inject_file_id = int(input("Enter the ID> "))
            except:
                logging.info("Must be a number!")
        
        inject_file = autorun_files[inject_file_id]
        logging.info("Injecting into " + inject_file.name)
        injected = inject_eal_load(inject_file)
    else:
        injected = inject_eal_load(autorun_files[0])
    
    if (not injected):
        logging.critical("Error; Unable to inject into autorun file.. this may be because no such file exists or " +
                        "something bad happened... Copy the following code into an autorun file on BOTH server and client realm (or shared):")
        logging.critical(f"AddCSLuaFile(\"{loader_config_dir.name}/eal.lua\")\ninclude(\"{loader_config_dir.name}/eal.lua\")")
        return
    else:
        logging.info("Injected successfully...")
        logging.info("EAL complete!")
        return



if __name__ == "__main__":
    main()
    